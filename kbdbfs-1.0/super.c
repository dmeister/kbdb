/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: super.c,v 1.18 2003/12/22 10:32:31 zubair Exp $
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_kdb3fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "kdb3fs.h"



STATIC void
kdb3fs_read_inode(inode_t *inode)
{

	print_entry_location();
	
	inode->i_version = ++event;	/* increment inode version */
	inode->i_op = &kdb3fs_main_iops;
	inode->i_fop = &kdb3fs_main_fops;

	/*
	 * OK, the above was a hack, which is now turned off because it may
	 * cause a panic/oops on some systems.  The correct way to export a
	 * "nodev" filesystem is via using nfs-utils > 1.0 and the "fsid=" export
	 * parameter, which requires 2.4.20 or later.
	 */

	inode->i_mapping->a_ops = &kdb3fs_aops;
	
	print_exit_location();
}



/*
 * No need to call write_inode() on the lower inode, as it
 * will have been marked 'dirty' anyway. But we might need
 * to write some of our own stuff to disk.
 */
STATIC void
kdb3fs_write_inode(inode_t *inode, int sync)
{
	int err = 0;
	
	print_entry_location();

	err = kdb3fs_copy_inode_to_DB(inode, metadata_dbp);
#ifdef KERNEL_DEBUG
	printk("\nCalling do_sync() in kdb3fs_write_inode\n");
#endif
	err = do_sync(stopd(inode->i_sb)->ksi_writeinode_sync);
out:
	print_exit_location();
}



STATIC void
kdb3fs_put_inode(inode_t *inode)
{
	print_entry_location();
	fist_dprint(8, "%s i_count = %d, i_nlink = %d\n", __FUNCTION__,
		    atomic_read(&inode->i_count), inode->i_nlink);
	/*
	 * This is really funky stuff:
	 * Basically, if i_count == 1, iput will then decrement it and this inode will be destroyed.
	 * It is currently holding a reference to the hidden inode.
	 * Therefore, it needs to release that reference by calling iput on the hidden inode.
	 * iput() _will_ do it for us (by calling our clear_inode), but _only_ if i_nlink == 0.
	 * The problem is, NFS keeps i_nlink == 1 for silly_rename'd files.
	 * So we must for our i_nlink to 0 here to trick iput() into calling our clear_inode.
	 */
//	if (atomic_read(&inode->i_count) == 1)
//		inode->i_nlink = 0;
	print_exit_location();
}



/*
 * we now define delete_inode, because there are two VFS paths that may
 * destroy an inode: one of them calls clear inode before doing everything
 * else that's needed, and the other is fine.  This way we truncate the inode
 * size (and its pages) and then clear our own inode, which will do an iput
 * on our and the lower inode.
 */
STATIC void
kdb3fs_delete_inode(inode_t *inode)
{
	DB *dbp;
	struct dbkey tmp_dbkey;
	int num_pages = 0;
	int i;
	ino_t inum;
	DBT data, key;
	int err = 0;
	ino_t inode_num;
	
	print_entry_location();

	/* unlink entry in metadata.db */
	dbp = metadata_dbp;
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data));
	inode_num = inode->i_ino; 

	key.data = (void *)&inode_num;
	key.size = sizeof(u_int32_t);
	if ((err = dbp->del(dbp, NULL, &key, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("db: %s: key was deleted from metadata.db\n", (char *)key.data); 
#endif
	} else { 
		printk("error deleting %s in metadata.db\n", (char *)key.data); 
		goto err; 
	} 
		
	
	num_pages = inode->i_size / PAGE_CACHE_SIZE;
	if (inode->i_size % PAGE_CACHE_SIZE) {
		num_pages += 1;
	}
	if (num_pages == 0) {
		num_pages = 1;
	}

	for (i = 0; i < num_pages; i++) {
		dbp = data_dbp;
		memset(&key, 0, sizeof(key)); 
		memset(&data, 0, sizeof(data)); 
		
		tmp_dbkey.inum = (u_int32_t)inode->i_ino;
		tmp_dbkey.p_index = i;
		
		key.data = &tmp_dbkey;
		key.size = sizeof(struct dbkey);
		
		if ((err = dbp->del(dbp, NULL, &key, 0)) == 0) {
#ifdef KERNEL_DEBUG
			printk("key %d:%d was deleted from data.db\n", (int)tmp_dbkey.inum, (int)tmp_dbkey.p_index); 
#endif
		} else { 
			//printk("error deleting %d:%d in data.db\n", (int)tmp_dbkey.inum, (int)tmp_dbkey.p_index);
			err = 0;
			break;
		}
	}
	
	inode->i_size = 0;		/* every f/s seems to do that */
	clear_inode(inode);
err:
	print_exit_location();
}






/* final actions when unmounting a file system */
STATIC void
kdb3fs_put_super(super_block_t *sb)
{
	DBT key, data; 
	int ret;
	
	print_entry_location();

	fist_dprint(6, "kdb3fs: released super\n");
	
	//printk("CLOSE DATA.DB\n");
	if ( (data_dbp->close(data_dbp, 0)) != 0 ) {
		printk("CLOSE: close failed for data\n");
	}
	//printk("CLOSE METADATA.DB\n");
	if ( (metadata_dbp->close(metadata_dbp, 0)) != 0 ) {
		printk("CLOSE: close failed for metadata\n");
	}
	//printk("CLOSE DIRENT.DB\n");
	if ( (dirent_dbp->close(dirent_dbp, 0)) != 0 ) {
		printk("CLOSE: close failed for dirent\n");
	}
	
	data_dbp = NULL;
	metadata_dbp = NULL;
	dirent_dbp = NULL;
out:

	if (stopd(sb)) {
		KFREE(stopd(sb));
		stopd(sb) = NULL;
	}
	print_exit_location();
}


#ifdef NOT_NEEDED
/*
 * This is called in do_umount before put_super.
 * The superblock lock is not held yet.
 * We probably do not need to define this or call write_super
 * on the hidden_sb, because sync_supers() will get to hidden_sb
 * sooner or later.  But it is also called from file_fsync()...
 */
STATIC void
kdb3fs_write_super(super_block_t *sb)
{
	return;
}
#endif /* NOT_NEEDED */


STATIC int
kdb3fs_statfs(super_block_t *sb, struct statfs *buf)
{
	int err = 0;
	super_block_t *hidden_sb;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


/*
 * XXX: not implemented.  This is not allowed yet.
 * Should we call this on the hidden_sb?  Probably not.
 */
STATIC int
kdb3fs_remount_fs(super_block_t *sb, int *flags, char *data)
{
	return -ENOSYS;
}


/*
 * Called by iput() when the inode reference count reached zero
 * and the inode is not hashed anywhere.  Used to clear anything
 * that needs to be, before the inode is completely destroyed and put
 * on the inode free list.
 */
STATIC void
kdb3fs_clear_inode(inode_t *inode)
{

	print_entry_location();

//	fist_checkinode(inode, "kdb3fs_clear_inode IN");
	/*
	 * Decrement a reference to a hidden_inode, which was incremented
	 * by our read_inode when it was created initially.
	 */
//	iput(itohi(inode));
	// XXX: why this assertion fails?
	// because it doesn't like us
	// ASSERT((inode->i_state & I_DIRTY) == 0);
//	KFREE(itopd(inode));
	//itopd(inode) = NULL;

	print_exit_location();
}


/*
 * Called in do_umount() if the MNT_FORCE flag was used and this
 * function is defined.  See comment in linux/fs/super.c:do_umount().
 * Used only in nfs, to kill any pending RPC tasks, so that subsequent
 * code can actually succeed and won't leave tasks that need handling.
 *
 * PS. I wonder if this is somehow useful to undo damage that was
 * left in the kernel after a user level file server (such as amd)
 * dies.
 */
STATIC void
kdb3fs_umount_begin(super_block_t *sb)
{
	super_block_t *hidden_sb;

	print_entry_location();
#if 0
	hidden_sb = stohs(sb);

	if (hidden_sb->s_op->umount_begin)
		hidden_sb->s_op->umount_begin(hidden_sb);
#endif
	print_exit_location();
}


struct super_operations kdb3fs_sops =
{
	read_inode:	kdb3fs_read_inode,
	write_inode:	kdb3fs_write_inode,
	put_inode:	kdb3fs_put_inode,
	delete_inode:	kdb3fs_delete_inode,
	put_super:	kdb3fs_put_super,
//	statfs:		kdb3fs_statfs,
//	remount_fs:	kdb3fs_remount_fs,
//	clear_inode:	kdb3fs_clear_inode,
//	umount_begin:	kdb3fs_umount_begin,
};

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */

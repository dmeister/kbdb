/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: inode.c,v 1.27 2003/12/22 10:32:31 zubair Exp $
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_kdb3fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "kdb3fs.h"


STATIC int
kdb3fs_create(inode_t *dir, dentry_t *dentry, int mode)
{
	int err;
	struct stat tmp;
	DBT key, data;  
	int ret; 
	DBC *dbcp;
	struct dbkey keydata;

	print_entry_location();

	err = kdb3fs_interpose(dentry, dir->i_sb, 0, 0, mode);
	if (err)
		goto out;

	//create entry in the dirent.db
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	key.data = (void *)dentry->d_name.name; 
	key.size = dentry->d_name.len + 1;

	data.data = (u_int32_t *) &dentry->d_inode->i_ino;
	data.size = sizeof(u_int32_t);

	if ((ret = dirent_dbp->put(dirent_dbp, NULL, &key, &data, 0)) == 0) {
#ifdef KERNEL_DEBUG
		//	printk("IN CREATE(), db: key stored=%s, data stored=%d\n", (char *)key.data, *((u_int32_t *)data.data)); 
#endif
	} else { 
		printk("Error in putting, in create()\n");
		goto out; 
	} 

	// creating entry in data.db
#if 0
	keydata.inum = (u_int32_t) dentry->d_inode->i_ino;
	keydata.p_index = 0;
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	key.data = &keydata;
	key.size = sizeof(keydata);
	data.data = "";
	data.size = 0;

	if ((ret = data_dbp->put(data_dbp, NULL, &key, &data, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("IN CREATE(), db: key stored=%s, data stored=%s\n", (char *)key.data, (char *)data.data); 
#endif
	} else { 
		printk("2. Error in putting into data.db, in create()\n");
		goto out; 
	} 
#endif
	//error	XXX: Why do this here?

	dir->i_atime = dentry->d_inode->i_atime;
	kdb3fs_copy_inode_to_DB(dir, metadata_dbp);
out:
	//printk("CREATED file=%s\n", dentry->d_name.name);
	print_exit_status(err);
	return err;
}






STATIC dentry_t *
kdb3fs_lookup(inode_t *dir, dentry_t *dentry)
{
	/* we have to return a dentry object. lookup name in dirent.db table, if present,*/
	int err = 0;	
	DBC *dbcp;
	DBT tk, td;
	int ret, c;
	int isFound = 0;
	u_int32_t inode_num;

	print_entry_location();
	
	fist_print_inode("IN Lookup, parent inode", dir);
	fist_print_dentry("IN Lookup, dentry to lookup", dentry);

	dentry->d_op = &kdb3fs_dops;
	
	/* lookup dentry->d_name.name in the dirent.db, if it exists then fill in the inode structure
	   from the metadata.db database */
	memset(&tk, 0, sizeof(tk));
	memset(&td, 0, sizeof(td));
	tk.data = (void *) dentry->d_name.name;  
	tk.size = dentry->d_name.len + 1;
	
	if ((ret = dirent_dbp->get(dirent_dbp, NULL, &tk, &td, 0)) == 0) {
#ifdef KERNEL__DEBUG
		printk("FOUND %s\n", (char *)tk.data);
#endif
		isFound = 1;
	} else {
#ifdef KERNEL__DEBUG
		printk("NOT FOUND %s\n", (char *)tk.data);
#endif
	}
	
	if (isFound) {
		inode_num = *(u_int32_t *)td.data;
		
                /* last parameter will change, it corresponds to the inode number from the database */
		if (kdb3fs_interpose(dentry, dir->i_sb, 1, inode_num, 0)) {
			printk("error from interpose, inode_num=%d, dentry=%s!!\n", inode_num, dentry->d_name.name);
		}
	} else {
		/* did not find entry, hence make it a negative dentry */
		d_add(dentry, NULL);
		goto out;
	}
out:	
	fist_print_dentry("OUT Lookup, dentry looked up", dentry);
	print_exit_status(err);
	return ERR_PTR(err);
}



STATIC int
kdb3fs_link(dentry_t *old_dentry, inode_t *dir, dentry_t *new_dentry)
{
	int err;
	dentry_t *hidden_old_dentry;
	dentry_t *hidden_new_dentry;
	dentry_t *hidden_dir_dentry;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_unlink(inode_t *dir, dentry_t *dentry)
{
	int err = 0;
	DB *dbp;
	DBT  data, key;
	
	print_entry_location();

	//printk("TRYING TO UNLINK=%s inode size=%d\n", dentry->d_name.name, (int)dentry->d_inode->i_size);
	/* unlink dentry from all three databases */

	/* unlink entry in dirent.db */
	dbp = dirent_dbp;
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	key.data = (void *) dentry->d_name.name;
	key.size = dentry->d_name.len + 1;
	if ((err = dbp->del(dbp, NULL, &key, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("db: %s: key was deleted from dirent.db\n", (char *)key.data); 
#endif
	} else { 
		printk("error deleting %s in dirent.db\n", (char *)key.data); 
		goto err; 
	} 
	
	dentry->d_inode->i_nlink = 0;
err:
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_symlink(inode_t *dir, dentry_t *dentry, const char *symname)
{
	int err;
	dentry_t *hidden_dentry;
	dentry_t *hidden_dir_dentry;
	char *encoded_symname;
	unsigned int encoded_symlen;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_mkdir(inode_t *dir, dentry_t *dentry, int mode)
{
	int err;
	dentry_t *hidden_dentry;
	dentry_t *hidden_dir_dentry;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_rmdir(inode_t *dir, dentry_t *dentry)
{
	int err = 0;
	dentry_t *hidden_dentry;
	dentry_t *hidden_dir_dentry;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_mknod(inode_t *dir, dentry_t *dentry, int mode, int dev)
{
	int err;
	dentry_t *hidden_dentry;
	dentry_t *hidden_dir_dentry;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_rename(inode_t *old_dir, dentry_t *old_dentry,
	      inode_t *new_dir, dentry_t *new_dentry)
{
	int err;
	dentry_t *hidden_old_dentry;
	dentry_t *hidden_new_dentry;
	dentry_t *hidden_old_dir_dentry;
	dentry_t *hidden_new_dir_dentry;

	print_entry_location();

//#warning make this stuff work
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_readlink(dentry_t *dentry, char *buf, int bufsiz)
{
	int err;
	dentry_t *hidden_dentry;
	char *decoded_name, *hidden_buf;
	mm_segment_t old_fs;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_follow_link(dentry_t *dentry, struct nameidata *nd)
{
	char *buf;
	int len = PAGE_SIZE, err;
	mm_segment_t old_fs;

	print_entry_location();
	err = -ENOSYS;
	print_exit_status(err);
	return err;
}


/*
 * Function to handle truncations extending the size of the file for non-SCA
 * file systems.
 */
STATIC int
kdb3fs_truncate(dentry_t *dentry, loff_t new_length)
{
	inode_t *inode = dentry->d_inode;
	file_t fake_file;
	page_t *tmp_page;
	int index;
	unsigned to;
	int err = 0;
	int num_pages = 0;
	int i = 0;
	int new_len_page_number;
	DBT data, key;
	struct dbkey tmp_dbkey;
	DB *dbp;


	print_entry_location();

	/* XXX: We don't need to do fill zeros, fill zero's sucks. Sparse files rock.	
	 * if this is a truncate past the end of the file, call wrapfs_fill_zeros
	 */
	if (new_length > inode->i_size) {
		
		err = -ENOSYS;

	} else {
		
		num_pages = dentry->d_inode->i_size / PAGE_CACHE_SIZE;
		if (dentry->d_inode->i_size % PAGE_CACHE_SIZE) {
			num_pages += 1;
		}
		if (num_pages == 0) {
			num_pages = 1;
		}
		
		new_len_page_number = new_length / PAGE_CACHE_SIZE;
		if (new_length % PAGE_CACHE_SIZE) {
			new_len_page_number += 1;
		}
		//	printk("\nnew_len_page_number=%d, num_pages=%d\n", new_len_page_number, num_pages);
		for (i = new_len_page_number; i < num_pages; i++) {
			dbp = data_dbp;
			memset(&key, 0, sizeof(key)); 
			memset(&data, 0, sizeof(data)); 
			
			tmp_dbkey.inum = (u_int32_t)inode->i_ino;
			tmp_dbkey.p_index = i;
			
			key.data = &tmp_dbkey;
			key.size = sizeof(struct dbkey);
			
			if ((err = dbp->del(dbp, NULL, &key, 0)) == 0) {
#ifdef KERNEL_DEBUG
				printk("key %d:%d was deleted from data.db\n", (int)tmp_dbkey.inum, (int)tmp_dbkey.p_index); 
#endif
			} else { 
				//printk("error deleting %d:%d in data.db\n", (int)tmp_dbkey.inum, (int)tmp_dbkey.p_index);
				err = 0;
				break;
			}
		}
		//now call truncate_inode_pages()
		truncate_inode_pages(dentry->d_inode->i_mapping, new_length);
		dentry->d_inode->i_size = new_length;
	}
	
	
//	printk("in truncate NEW inode->size=%d\n", (int)dentry->d_inode->i_size);
out:
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_permission(inode_t *inode, int mask)
{
	inode_t *hidden_inode;
	int mode;
	int err = 0;
	DB *dbp;
	DBC *dbcp;

	print_entry_location();
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_inode_revalidate(dentry_t *dentry)
{
	int err = 0;
	dentry_t *hidden_dentry;
	inode_t *hidden_inode;

	print_entry_location();
#if 0
	fist_print_dentry("kdb3fs_inode_revalidate IN", dentry);
	fist_print_inode("kdb3fs_inode_revalidate IN", dentry->d_inode);
	fist_print_inode("kdb3fs_inode_revalidate OUT", dentry->d_inode);
	fist_print_dentry("kdb3fs_inode_revalidate OUT", dentry);
#endif
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_setattr(dentry_t *dentry, struct iattr *ia)
{
	int err = 0;
	dentry_t *hidden_dentry;
	inode_t *inode;
	inode_t *hidden_inode;

	print_entry_location();

	inode = dentry->d_inode;

	if (ia->ia_valid & ATTR_SIZE) {
		err = kdb3fs_truncate(dentry, ia->ia_size);
		if (err < 0)
			goto out;
	}
	/*
	 * Changed the above to only mark the inode as dirty, as
	 * opposed to copying it to the database
	 */
	mark_inode_dirty(inode);
out:
	print_exit_status(err);
	return err;
}


#ifdef NOT_USED_YET
STATIC int
kdb3fs_getattr(dentry_t *dentry, struct iattr *ia)
{
	return -ENOSYS;
}
#endif /* NOT_USED_YET */


struct inode_operations kdb3fs_symlink_iops =
{
	readlink:	kdb3fs_readlink,
	follow_link:	kdb3fs_follow_link,
	permission:	kdb3fs_permission,
	revalidate:	kdb3fs_inode_revalidate,
	setattr:	kdb3fs_setattr,
#if 0
	// XXX: off, b/c the VFS doesn't call getattr yet
	getattr:	kdb3fs_getattr,
#endif
};

struct inode_operations kdb3fs_dir_iops =
{
	create:		kdb3fs_create,
	lookup:		kdb3fs_lookup,
	link:		kdb3fs_link,
	unlink:		kdb3fs_unlink,
	symlink:	kdb3fs_symlink,
	mkdir:		kdb3fs_mkdir,
	rmdir:		kdb3fs_rmdir,
	mknod:		kdb3fs_mknod,
	rename:		kdb3fs_rename,
	/* no readlink/follow_link for non-symlinks */
	// off because we have setattr
	permission:	kdb3fs_permission,
	revalidate:	kdb3fs_inode_revalidate,
	setattr:	kdb3fs_setattr,
#if 0
	// XXX: off, b/c the VFS doesn't call getattr yet
	getattr:	kdb3fs_getattr,
#endif
};

struct inode_operations kdb3fs_main_iops =
{
	permission:	kdb3fs_permission,
	revalidate:	kdb3fs_inode_revalidate,
	setattr:	kdb3fs_setattr,
#if 0
	// XXX: off, b/c the VFS doesn't call getattr yet
	getattr:	kdb3fs_getattr,
#endif
};

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */

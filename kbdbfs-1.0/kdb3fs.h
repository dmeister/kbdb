/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: kdb3fs.h,v 1.19 2003/12/21 14:43:57 jdave Exp $
 */

#ifndef __KDB3FS_H_
#define __KDB3FS_H_

#ifdef __KERNEL__

#include "db.h"
#include <asm/stat.h>
#include <linux/kdev_t.h>
#include <linux/highuid.h>

DB *dirent_dbp, *metadata_dbp, *data_dbp;

/*
 * STRUCTURES:
 */

/*
 * Definitions for user and kernel code
 */
#define KDB3FS_MAX_FILE_LENGTH (1024 * 1024 * 10) 

/* Maximum file size of the filesystem
 * based on kdb3 is currently restricted
 * to 1MB.
 */
#define KDB3FS_ROOT_INO 2 /* Root (/) inode number should be 2 as '.' and
			   * '..' will share the inode number 1.
			   */
#define KDB3FS_BLK_SIZE 4096 /* Block size in bytes */

/* Mount time flags
 * SYNC_DATA : syncs the data database
 * SYNC_MD : syncs the metadata database
 * SYNC_DIRENT : syncs the dirent database 
 */
#define SYNC_DATA     1
#define SYNC_MD       2
#define SYNC_DIRENT   4

/* Turn this on to include code that counts writes and writes in the middle */
/* #undef FIST_COUNT_WRITES */

/* fist file systems superblock magic */
# define KDB3FS_SUPER_MAGIC 0xf15f


/* Key in the data.db is inode->i_ino || page->index */
struct dbkey {
	u_int32_t inum;
	unsigned long p_index;
};

/* kdb3fs inode data in memory */
struct kdb3fs_inode_info {
	inode_t *wii_inode;
};

/* kdb3fs dentry data in memory */
struct kdb3fs_dentry_info {
	dentry_t *wdi_dentry;
};


/* kdb3fs super-block data in memory */
struct kdb3fs_sb_info {
	super_block_t *wsi_sb;
	struct vfsmount *hidden_mnt;
	int ksi_writepage_sync;
	int ksi_writeinode_sync;
//	DB *dirent_dbp;
	//DB *data_dbp;
	//DB *metadata_dbp;
//	int test;
};

/* file private data. */
struct kdb3fs_file_info {
	DBC *dirent_cursor;
};

/*
 * MACROS:
 */

// File TO Private Data
# define ftopd(file) ((struct kdb3fs_file_info *)((file)->private_data))
// File TO Hidden File
# define ftohf(file) ((ftopd(file))->wfi_file)
// Inode TO Private Data
# define itopd(ino) ((struct kdb3fs_inode_info *)(ino)->u.generic_ip)
// Inode TO Hidden Inode
# define itohi(ino) (itopd(ino)->wii_inode)
# define vnode2lower itohi
// Superblock TO Private Data
# define stopd(super) ((struct kdb3fs_sb_info *)(super)->u.generic_sbp)
# define vfs2priv stopd
// Superblock TO Hidden Superblock
# define stohs(super) (stopd(super)->wsi_sb)
// Dentry TO Hidden Dentry (and private data --- for the future)
# define dtopd(dentry) ((struct kdb3fs_dentry_info *)(dentry)->d_fsdata)
# define dtohd(dent) (dtopd(dent)->wdi_dentry)
# define dir2lower dtohd
/* VMArea TO Hidden VMArea */
# define vmatohvma(vma) ((vm_area_t *)((vma)->vm_private_data))

# define sbt(sb) ((sb)->s_type->name)

/* macros to simplify non-SCA code */
#  define MALLOC_PAGE_POINTERS(hidden_pages, num_hidden_pages)
#  define MALLOC_PAGEDATA_POINTERS(hidden_pages_data, num_hidden_pages)
#  define FREE_PAGE_POINTERS(hidden_pages, num)
#  define FREE_PAGEDATA_POINTERS(hidden_pages_data, num)
#  define FOR_EACH_PAGE
#  define CURRENT_HIDDEN_PAGE hidden_page
#  define CURRENT_HIDDEN_PAGEDATA hidden_page_data
#  define CURRENT_HIDDEN_PAGEINDEX page->index


/*
 * Flags for kdb3fs_{en,de}code_filename
 * DO_DOTS means the special entries . and .. should be encoded (for symlink)
 * SKIP_DOTS means they should be preserved intact
 */
#  define DO_DOTS   0
#  define SKIP_DOTS 1

/*
 * EXTERNALS:
 */
extern struct file_operations kdb3fs_main_fops;
extern struct file_operations kdb3fs_dir_fops;
extern struct inode_operations kdb3fs_main_iops;
extern struct inode_operations kdb3fs_dir_iops;
extern struct inode_operations kdb3fs_symlink_iops;
extern struct super_operations kdb3fs_sops;
extern struct dentry_operations kdb3fs_dops;
extern struct vm_operations_struct kdb3fs_shared_vmops;
extern struct vm_operations_struct kdb3fs_private_vmops;
extern struct address_space_operations kdb3fs_aops;

#if defined(FIST_FILTER_DATA) || defined(FIST_FILTER_SCA)
extern int kdb3fs_fill_zeros(file_t *file, page_t *page, unsigned from);
# endif /* FIST_FILTER_DATA || FIST_FILTER_SCA */
extern int kdb3fs_decode_block(ino_t inum, unsigned long page_index, char *to, int len);
extern int kdb3fs_encode_block(const char *from, ino_t inum, unsigned long page_index,int len);
extern int kdb3fs_decode_filename(const char *name, int length, char **decoded_name, int skip_dots, const vnode_t *vp, const vfs_t *vfsp);
extern int kdb3fs_encode_filename(const char *name, int length, char **encoded_name, int skip_dots, const vnode_t *vp, const vfs_t *vfsp);

#  define kdb3fs_hidden_dentry(d) __kdb3fs_hidden_dentry(__FILE__,__FUNCTION__,__LINE__,(d))
extern dentry_t *__kdb3fs_hidden_dentry(char *file, char *func, int line, dentry_t *this_dentry);
extern int kdb3fs_interpose(dentry_t *dentry, super_block_t *sb, int flag, int ino, int mode);


int do_sync(int when);

#  define copy_inode_size(dst, src) \
    dst->i_size = src->i_size; \
    dst->i_blocks = src->i_blocks;

static inline void
fist_copy_attr_atime(inode_t *dest, const inode_t *src)
{
	ASSERT(dest != NULL);
	ASSERT(src != NULL);
	dest->i_atime = src->i_atime;
}
static inline void
fist_copy_attr_times(inode_t *dest, const inode_t *src)
{
	ASSERT(dest != NULL);
	ASSERT(src != NULL);
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
}
static inline void
fist_copy_attr_timesizes(inode_t *dest, const inode_t *src)
{
	ASSERT(dest != NULL);
	ASSERT(src != NULL);
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
	copy_inode_size(dest, src);
}
static inline void
kdb3fs_init_attr_all(inode_t *dest, int flag)
{
	print_entry_location();
	ASSERT(dest != NULL);
	if(flag) {
		dest->i_mode = S_IRUGO | S_IWUGO | S_IFDIR;
		dest->i_nlink = 2;
	} else {
		dest->i_mode = S_IRUGO | S_IWUGO | S_IFREG;
		dest->i_nlink = 1;
	}
	dest->i_uid = 0;
	dest->i_gid = 0;
	//dest->i_rdev = src->i_rdev;
	dest->i_atime = 0;//src->i_atime;
	dest->i_mtime = 0;//src->i_mtime;
	dest->i_ctime = 0;//src->i_ctime;
	dest->i_blksize = KDB3FS_BLK_SIZE;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,12)
	dest->i_blkbits = KDB3FS_BLK_SIZE * 8;
# endif /* linux 2.4.12 and newer */
	dest->i_size = 0; /* Initial file size set to 0 */
	dest->i_blocks = 0; /* Initial block size set to 0 */
    
	dest->i_attr_flags = 0;
	print_exit_location();
}
static inline void
fist_copy_attr_all(inode_t *dest, const inode_t *src)
{
	print_entry_location();
	ASSERT(dest != NULL);
	ASSERT(src != NULL);
	dest->i_mode = src->i_mode;
	dest->i_nlink = src->i_nlink;
	dest->i_uid = src->i_uid;
	dest->i_gid = src->i_gid;
	dest->i_rdev = src->i_rdev;
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
	dest->i_blksize = src->i_blksize;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,12)
	dest->i_blkbits = src->i_blkbits;
# endif /* linux 2.4.12 and newer */
	copy_inode_size(dest, src);

	dest->i_attr_flags = src->i_attr_flags;
	print_exit_location();
}



static inline int
kdb3fs_copy_DB_to_inode(DB *metadata_dbp, inode_t * inode)
{
	char tmp[10];
	DBT tk, td;
	int ret = 0;
	struct stat *buf;
	
	print_entry_location();

//	sprintf(tmp, "%d", (int)inode->i_ino);

	// now read stat information using "inode_num" as the key from the metadata.db database.
	memset(&tk, 0, sizeof(tk)); 
	memset(&td, 0, sizeof(td)); 
	tk.data = (u_int32_t *) &inode->i_ino;  
	tk.size = sizeof(u_int32_t);
	
	if ((ret = metadata_dbp->get(metadata_dbp, NULL, &tk, &td, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("IN kdb3fs_copy_DB_to_inode(), metadata.db: %s: key retrieved: size=%d\n", inode->i_ino, td.size); 
#endif
	} else {
		printk("get operation for %d unsucessful\n", *((u_int32_t *)tk.data)); 
		goto err;
	}

	buf = (struct stat *) td.data;
		
	inode->i_mode = buf->st_mode;
	inode->i_size = buf->st_size;
	inode->i_nlink = buf->st_nlink;
        inode->i_uid = buf->st_uid;
        inode->i_gid = buf->st_gid;
	//  tmp.st_rdev = kdev_t_to_nr(inode->i_rdev);
	inode->i_atime = buf->st_atime;
	inode->i_mtime = buf->st_mtime;
	inode->i_ctime = buf->st_ctime;
err:
	print_exit_location();
	return ret;
}





static inline int
kdb3fs_copy_inode_to_DB(inode_t *inode, DB *metadata_dbp)
{
	struct stat tmp;
	DBT key, data;  
	int ret; 
	int inode_num;
//	char buf[10];

	DBT tk, td;
	struct stat *statbuf;
	
	print_entry_location();
	
	tmp.st_dev = kdev_t_to_nr(inode->i_dev);
        tmp.st_ino = inode->i_ino;
        tmp.st_mode = inode->i_mode;
        tmp.st_nlink = inode->i_nlink;
        SET_OLDSTAT_UID(tmp, inode->i_uid);
        SET_OLDSTAT_GID(tmp, inode->i_gid);
        tmp.st_rdev = kdev_t_to_nr(inode->i_rdev);
        tmp.st_size = inode->i_size;
        tmp.st_atime = inode->i_atime;
        tmp.st_mtime = inode->i_mtime;
        tmp.st_ctime = inode->i_ctime;
	
//	sprintf(buf, "%d", (int)inode->i_ino);
	
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data));
	//------ 
	//inode_num = (int)inode->i_ino;
	//key.data = (void *)&inode_num;
	//key.size = sizeof(int);
	//------
	key.data = (u_int32_t *) &inode->i_ino; 
	key.size = sizeof(u_int32_t);
	data.data = (void *) &tmp;
	data.size = sizeof(struct stat);
	
	if ((ret = metadata_dbp->put(metadata_dbp, NULL, &key, &data, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("db: key stored=%d, mode=%x\n", *(u_int32_t *)key.data, tmp.st_mode); 
#endif
	} else { 
		printk("error in kdb3fs_copy_inode_to_DB\n");
		goto err; 
	} 
err:
	print_exit_location();
	return ret;
}



static inline 
void displayDB(char *name, DB *dbp) 
{
	DBC *dbcp;
	DBT tk, td;
	int ret, c;
	
	memset(&tk, 0, sizeof(tk));
	memset(&td, 0, sizeof(td));
	printk("Records in %s: \n", name);
	printk("key        data           size\n");
	printk("--------------------\n");
	if ((ret = dbp->cursor(dbp, NULL, &dbcp, 0)) == 0) {
		c = 0;
		while ((ret = dbcp->c_get(dbcp, &tk, &td, DB_NEXT)) == 0) {
			struct stat *b = (struct stat *)td.data;
			
			if (strcmp(name, "metadata.db") == 0)
				printk("inode_inum=%d      file size=%d\n", *(u_int32_t *)tk.data, (int)b->st_size); 
			else 
				if (strcmp(name, "data.db") == 0) {
					struct dbkey *key = (struct dbkey *)tk.data;
					u_int32_t inum = key->inum;
					int p_index = key->p_index;
					printk("%d:%d   size=%d\n", inum, p_index, td.size);
				}  else 
					printk("%s           %d\n", (char *)tk.data, *(u_int32_t *)td.data);
			c ++;
			tk.data = "";
			td.data = "";
			//memset(&tk, 0, sizeof(tk));
			//memset(&td, 0, sizeof(td));
		}
		dbcp->c_close(dbcp);//close cursor
		printk("Total %d records in db\n", c);
	}
	printk("\n\n");
}







/* auto-generated extern definitions */


#endif /* __KERNEL__ */

/* ioctls */


#endif	/* not __KDB3FS_H_ */

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */

/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: mmap.c,v 1.19 2003/12/22 10:32:31 zubair Exp $
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_kdb3fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "kdb3fs.h"


#ifdef FIST_COUNT_WRITES
/* for counting writes in the middle vs. regular writes */
unsigned long count_writes = 0, count_writes_middle = 0;
#endif /* FIST_COUNT_WRITES */

/* forward declaration of commit write and prepare write */
STATIC int kdb3fs_commit_write(file_t *file, page_t *page, unsigned from, unsigned to);
STATIC int kdb3fs_prepare_write(file_t *file, page_t *page, unsigned from, unsigned to);


STATIC int
kdb3fs_writepage(page_t *page)
{
	int err = 0;
	inode_t *inode;
	inode_t *hidden_inode;
	page_t *hidden_page;
	char *kaddr, *hidden_kaddr;


	print_entry_location();

	inode = page->mapping->host;

	/*
	 * writepage is called when shared mmap'ed files need to write
	 * their pages, while prepare/commit_write are called from the
	 * non-paged write() interface.  (However, in 2.3 the two interfaces
	 * share the same cache, while in 2.2 they didn't.)
	 *
	 * So we pretty much have to duplicate much of what commit_write does.
	 */

	/* get page address, and encode it */
	kaddr = (char *) kmap(page);

	kdb3fs_encode_block(kaddr, inode->i_ino, page->index, PAGE_CACHE_SIZE);
	kunmap(page);
	SetPageUptodate(page);
	do_sync(stopd(inode->i_sb)->ksi_writepage_sync);

out:
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,1)
	UnlockPage(page);
# endif /* kernel 2.4.1 and newer */
	print_exit_status(err);
	return err;
}


/*
 * get one page from cache or lower f/s, return error otherwise.
 * returns unlocked, up-to-date page (if ok), with increased refcnt.
 */
page_t *
kdb3fs_get1page(file_t *file, int index)
{
	page_t *page = NULL;
	dentry_t *dentry;
	inode_t *inode;
	struct address_space *mapping;
	int err;

	print_entry_location();
#if 0
	dentry = file->f_dentry; /* CPW: Moved below print_entry_location */
	inode = dentry->d_inode;
	mapping = inode->i_mapping;

	if (Page_Uptodate(page)) {
		printk("<0>Should we really be called on a page that is up to date here?\n");
		ASSERT(NULL);
	}

	fist_dprint(8, "%s: read page index %d pid %d\n", __FUNCTION__, index, current->pid);
	if (index < 0) {
		printk("%s BUG: index=%d\n", __FUNCTION__, index);
		page = ERR_PTR(-EIO);
		goto out;
	}
	page = read_cache_page(mapping,
			       index,
			       (filler_t *) mapping->a_ops->readpage,
			       (void *) file);
	if (IS_ERR(page))
		goto out;
	wait_on_page(page);
	if (!Page_Uptodate(page)) {
		lock_page(page);
		err = mapping->a_ops->readpage(file, page);
		if (err) {
			page = ERR_PTR(err);
			goto out;
		}
		wait_on_page(page);
		if (!Page_Uptodate(page)) {
			page = ERR_PTR(-EIO);
			goto out;
		}
	}
#endif
out:
	print_exit_pointer(page);
	return page;
}



/*
 * readpage is called from generic_page_read and the fault handler.
 * If your file system uses generic_page_read for the read op, it
 * must implement readpage.
 *
 * Readpage expects a locked page, and must unlock it.
 */
STATIC int
kdb3fs_do_readpage(file_t *file, page_t *page)
{
	int err = -EIO;
	dentry_t *dentry;
	file_t *hidden_file = NULL;
	dentry_t *hidden_dentry;
	inode_t *inode;
	inode_t *hidden_inode;
	char *page_data;
	page_t *hidden_page;
	char *hidden_page_data;
	int real_size;

	print_entry_location();

	dentry = file->f_dentry; /* CPW: Moved below print_entry_location */
	inode = dentry->d_inode;

	/* map pages, get their addresses */
	page_data = (char *) kmap(page);

	/* if decode_block could fail, then return error */
	err = 0;
	real_size = inode->i_size - (page->index << PAGE_CACHE_SHIFT);
	if (real_size <= 0)
		memset(page_data, 0, PAGE_CACHE_SIZE);
	else if (real_size < PAGE_CACHE_SIZE) {
		kdb3fs_decode_block(inode->i_ino, page->index, page_data, real_size);
		memset(page_data + real_size, 0, PAGE_CACHE_SIZE - real_size);
	} else
		kdb3fs_decode_block(inode->i_ino, page->index, page_data, PAGE_CACHE_SIZE);

	kunmap(page);

out:
	if (err == 0)
		SetPageUptodate(page);
	else
		ClearPageUptodate(page);

	print_exit_status(err);
	return err;
}

STATIC int
kdb3fs_readpage(file_t *file, page_t *page)
{
	int err;
	print_entry_location();

	err = kdb3fs_do_readpage(file, page);

	/*
	 * we have to unlock our page, b/c we _might_ have gotten a locked page.
	 * but we no longer have to wakeup on our page here, b/c UnlockPage does
	 * it
	 */
	UnlockPage(page);

	print_exit_status(err);
	return err;
}

STATIC int
kdb3fs_prepare_write(file_t *file, page_t *page, unsigned from, unsigned to)
{
	int err = 0;

	print_entry_location();

	/*
	 * we call kmap(page) only here, and do the kunmap
	 * and the actual downcalls, including unlockpage and uncache
	 * in commit_write.
	 */
	kmap(page);

	/* fast path for whole page writes */
	if (from == 0 && to == PAGE_CACHE_SIZE)
		goto out;
	/* read the page to "revalidate" our data */
	/* call the helper function which doesn't unlock the page */
	if (!Page_Uptodate(page))
		err = kdb3fs_do_readpage(file, page);

out:
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_commit_write(file_t *file, page_t *page, unsigned from, unsigned to)
{
	int err = 0;
	inode_t *inode;
	inode_t *hidden_inode;
	page_t *hidden_page;
	file_t *hidden_file = NULL;
	loff_t pos;
	unsigned bytes = to - from;


	print_entry_location();

	inode = page->mapping->host; /* CPW: Moved below print_entry_location */

	ASSERT(file != NULL);
	/*
	 * here we have a kmapped page, with data from the user copied
	 * into it.  we need to encode_block it, and then call the lower
	 * commit_write.  We also need to simulate same behavior of
	 * generic_file_write, and call prepare_write on the lower f/s first.
	 */

	if ((page->index << PAGE_CACHE_SHIFT) + to > inode->i_size) {
		/*
		 * If this call to commit_write had introduced holes and the code
		 * for handling holes was invoked, then the beginning of this page
		 * must be zeroed out as well:
		 *	zero out bytes from 'size_of_file%pagesize' to 'from'.
		 */
		if (from > (inode->i_size & ~PAGE_CACHE_MASK))
			memset((char*)page_address(page) + (inode->i_size & ~PAGE_CACHE_MASK), 0, from - (inode->i_size & ~PAGE_CACHE_MASK));
	}


	fist_dprint(8, "%s: encoding %d bytes\n", __FUNCTION__, bytes);
	set_page_dirty(page);

        /* we may havep to update i_size */
	pos = (page->index << PAGE_CACHE_SHIFT) + to;
	if (pos > inode->i_size) {
		inode->i_size = pos;
		mark_inode_dirty(inode);
	}

out_unlock:
	kunmap(page);		/* kmap was done in prepare_write */
out:
	/* we must set our page as up-to-date */
	if (err < 0)
		ClearPageUptodate(page);
	else
		SetPageUptodate(page);
	print_exit_status(err);
	return err;
}


STATIC int
kdb3fs_bmap(struct address_space *mapping, long block)
{
	int err = 0;
	inode_t *inode;
	inode_t *hidden_inode;

	print_entry_location();
#if 0
	inode = (inode_t *) mapping->host;
	hidden_inode = itohi(inode);

	if (hidden_inode->i_mapping->a_ops->bmap)
		err = hidden_inode->i_mapping->a_ops->bmap(hidden_inode->i_mapping, block);
#endif
	print_exit_location();
	return err;
}


/*
 * This function is copied verbatim from mm/filemap.c.
 * XXX: It should be simply moved to some header file instead -- bug Al about it!
 */
static inline int sync_page(struct page *page)
{
	struct address_space *mapping = page->mapping;

	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
		return mapping->a_ops->sync_page(page);
	return 0;
}


struct address_space_operations kdb3fs_aops =
{
	writepage:		kdb3fs_writepage,
	readpage:		kdb3fs_readpage,
	prepare_write:	        kdb3fs_prepare_write,
	commit_write:	        kdb3fs_commit_write,
	bmap:		        kdb3fs_bmap,
};

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */

/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: subr.c,v 1.2 2003/12/11 03:33:07 jdave Exp $
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_kdb3fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "kdb3fs.h"

#error do not compile this file directly. it is only an example.

/*
 * return the number of bytes written
 */
int
kdb3fs_encode_block(const char *from, char *to, int len, const vnode_t *this_vnode, const vfs_t *this_vfsp, u_long pagenum)
{
	
	memcpy(to, from, len);
	return len;
}


int
kdb3fs_decode_block(ino_t inum, char *to, int len)
{
	DBT  data, key;
	char tmp[10];
	int err;

	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	sprintf(tmp, "%d", (int)inum);
	key.data = tmp;
	key.size = strlen(tmp) + 1;
	if ((err = data_dbp->get(data_dbp, NULL, &key, &data, 0)) == 0) {
#ifdef KERNEL_DEBUG
		printk("db: %s: key retrieved: data was %s, size=%d\n", (char *)key.data, (char *)data.data, data.size); 
#endif
	} else {
		printk("get operation on %s unsucessful\n", (char *)key.data); 
	}

	memcpy(to, data.data, data.size);
	return data.size;
}

int
kdb3fs_encode_filename(const char *name, int length, char **encoded_name, int skip_dots, const vnode_t *this_vnode, const vfs_t *this_vfsp)
{
	int encoded_length;

	encoded_length = length + 1;
	*encoded_name = KMALLOC(encoded_length, GFP_KERNEL);
	if (!*encoded_name) {
		printk("<0>Kernel out of memory!\n");
		ASSERT(NULL);
	}
	memcpy(*encoded_name, name, length);
	(*encoded_name)[length] = '\0';

	return encoded_length;
}

/* returns length of decoded string, or -1 if error */
int
kdb3fs_decode_filename(const char *name, int length, char **decoded_name, int skip_dots, const vnode_t *this_vnode, const vfs_t *this_vfsp)
{
	int error = 0;

	*decoded_name = KMALLOC(length, GFP_KERNEL);
	if (!*decoded_name) {
		printk("<0>Kernel out of memory!\n");
		ASSERT(NULL);
	}
	memcpy(*decoded_name, name, length);
	error = length;

	return error;
}


/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */

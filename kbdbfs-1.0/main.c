/*
 * Copyright (c) 1997-2003 Erez Zadok
 * Copyright (c) 2001-2003 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from ftp://ftp.filesystems.org/pub/fist/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 *  $Id: main.c,v 1.25 2003/12/22 10:51:22 zubair Exp $
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_kdb3fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "kdb3fs.h"
#include <linux/module.h>

/* This definition must only appear after we include <linux/module.h> */
#ifndef MODULE_LICENSE
# define MODULE_LICENSE(GPL)
#endif /* not MODULE_LICENSE */

u_int32_t getMaxInode_BTREE(DB *dbp)
{
	DBC *dbcp;
	DBT key, data;
	u_int32_t ret = 0;
	u_int32_t max;
	//char tmp[10];

	print_entry_location();

	// if metadata was created using a BTREE access method then the largest inode number is the last
    	memset(&key, 0, sizeof(key));
	memset(&data, 0, sizeof(data));
	if ((ret = dbp->cursor(dbp, NULL, &dbcp, 0)) == 0) {
		if ((ret = dbcp->c_get(dbcp, &key, &data, DB_LAST)) == 0) {
			max = *((u_int32_t *)key.data);
		} else {
			printk("Error in getMaxInode_BTREE c_get\n");
			goto err;
		}
	} else {
		printk("Error in getMaxInode_BTREE dbp->cursor\n");
		goto err;
	}
	
	dbcp->c_close(dbcp);        //close cursor
	ret = max + 1;
	print_exit_status(ret);
err:
	return ret;
}



u_int32_t getMaxInode_RANDOM(DB *dbp)
{
	DBC *dbcp;
	DBT key, data;
	int ret;
	int c;
	u_int32_t max = -2, test;
	char tmp[10];

	// need to implement following algorithm here
	/*
	  int i, tmp;
	  int newinum=0;
	  for (i=0; i<10; i++) {
	     tmp = random();
	     if (tmp exists in database)
	      continue;
	     else {
	      newinum = tmp;
	     break;
	  }
	  if (newinum == 0) // 10 tries and we still didn't find it!
	  { search sequentially through database until you find an unused
	    number.
	  }
	*/

    	memset(&key, 0, sizeof(key));
	memset(&data, 0, sizeof(data));
	if ((ret = dbp->cursor(dbp, NULL, &dbcp, 0)) == 0) {
		while ((ret = dbcp->c_get(dbcp, &key, &data, DB_NEXT)) == 0) {
			max = *((u_int32_t *)key.data);
		}
		dbcp->c_close(dbcp);  //close cursor
	}
	if (ret != 0) {
		//printk("The inode number returned is %d\n",ret);
		//return ret;
	}
	//printk("### The inode number returned is %d\n",max+1);
	return max + 1;
}




/* sb we pass is kdb3fs's super_block */
int kdb3fs_interpose(dentry_t *dentry, super_block_t *sb, int flag, int ino, int mode)
{
	int err = 0;
	inode_t *inode;
	u_int32_t max_inode = 1;
	DBT key, data; 
	int ret;
	DBTYPE db_type;

	print_entry_location();

	ASSERT(dentry->d_inode == NULL);

	// get max inode only if doing a create operation
	if (flag) {
		max_inode = (u_int32_t) ino;	
	} else {
		if (metadata_dbp->get_type(metadata_dbp, &db_type) == 0) {
			if (db_type == DB_BTREE) {
				max_inode = getMaxInode_BTREE(metadata_dbp);
				if (max_inode < 0) {
					//printk("btree, MAX_INODE = %d\n",max_inode);
					goto out;
				}
			} else {
				max_inode = getMaxInode_RANDOM(metadata_dbp);	
				if (max_inode < 0) {
					//printk("rand, MAX_INODE = %d\n",max_inode);					
					goto out;
				}
			}
		}
	}
	
	/*
	 * We allocate our new inode below, by calling iget.
	 * iget will call our read_inode which will initialize some
	 * of the new inode's fields
	 */
	dentry->d_inode = iget(sb, max_inode);
	if(!dentry->d_inode) {
		err = -ENOMEM;
		//printk("Error in memory\n");
		goto out;
	}

	if (mode) {
		dentry->d_inode->i_mode = mode;
	}

	ASSERT(dentry->d_inode->i_sb == sb);
	inode = dentry->d_inode;
	inode->i_op = &kdb3fs_dir_iops;

	d_instantiate(dentry, inode);
	
	/* only (our) lookup wants to initialize the inode from the database.
	   create has to copy the inode metadata to the metadata.db database */
	if (flag) {
		err = kdb3fs_copy_DB_to_inode(metadata_dbp, inode);
		//printk("Return from copydb2inode : %d\n",err);
	} else {
		//printk("Writing inode: %d back to database\n",(int)inode->i_ino);
		err = kdb3fs_copy_inode_to_DB(inode, metadata_dbp);
		//printk("Return from copyinode2db : %d\n",err);
	}

out:
	print_exit_status(err);
	return err;
}


int do_sync(int when)
{
	int err = 0;

	if (when & SYNC_DIRENT) {
		err = dirent_dbp->sync(dirent_dbp, 0);
		if (err) {
			printk("ERROR in sync-ing dirent.db\n");
			goto out;
		} else {
			//	printk("\njust sync-ed dirent db\n\n");
		}
	}
	if (when & SYNC_MD) {
		err = metadata_dbp->sync(metadata_dbp, 0);
		if (err) {
			printk("ERROR in sync-ing metadata.db\n");
			goto out;
		} else {
			//		printk("\njust sync-ed metadata db\n\n");
		}
	}
	if (when & SYNC_DATA) {
		err = data_dbp->sync(data_dbp, 0);
		if (err) {
			printk("ERROR in sync-ing data.db\n");
			goto out;
		} else {
			//		printk("\njust sync-ed data db\n\n");
		}
	}
out:
	return err;
}



/*
 * Parse mount options: debug=N
 *
 * Sets default debugging level to N, if any.
 */
void
kdb3fs_parse_options(super_block_t *sb, char *options, char **database_dir)
{
	char *name, *tmp, *end;
	int err = 0;
	int mflags = 0;
	
	print_entry_location();
	
	/* We don't want to go off the end of our arguments later on. */
	for (end = options; *end; end++);
	
	while (options < end) {
		tmp = options;
		while (*tmp && *tmp != ',')
			tmp++;
		*tmp = '\0';
		if (!strncmp("dir=", options, 4)) {
			/* note: the name passed need not be encoded */
			name = options + 4;
			fist_dprint(4, "kdb3fs: using directory: %s\n", name);
			
			*database_dir = KMALLOC(strlen(name) + 1, GFP_KERNEL);
			if (!*database_dir) {
				printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
				goto out;
			}
			
			memset(*database_dir, 0, strlen(name) + 1);
			memcpy(*database_dir, name, strlen(name));
				
			printk("database_dir=%s\n", *database_dir);
		} else if (!strncmp("debug=", options, 6)) {
			int debug = simple_strtoul(options + 6, NULL, 0);
			fist_set_debug_value(debug);
		} else if (!strncmp("wpsync=", options, 6)) {
			stopd(sb)->ksi_writepage_sync = simple_strtoul(options + 6, NULL, 0);
		} else if (!strncmp("wisync=", options, 6)) {
			stopd(sb)->ksi_writeinode_sync = simple_strtoul(options + 6, NULL, 0);
		} else {
			printk(KERN_WARNING "kdb3fs: unrecognized option '%s'\n", options);
		}
		options = tmp + 1;
	}

out:
	print_exit_location();
}


#ifdef FIST_MALLOC_DEBUG
/* for malloc debugging */
static atomic_t kdb3fs_malloc_counter;

void *
kdb3fs_KMALLOC(size_t len, int flag, int line, const char *file)
{
	void *ptr = (void *) KMALLOC(len, flag);
	if (ptr) {
		atomic_inc(&kdb3fs_malloc_counter);
		printk("KM:%d:%p:%d:%s\n", atomic_read(&kdb3fs_malloc_counter),ptr, line, file);
	}
	return ptr;
}

void
kdb3fs_KFREE(void *ptr, int line, const char *file)
{
	atomic_inc(&kdb3fs_malloc_counter);
	printk("KF:%d:%p:%d:%s\n", atomic_read(&kdb3fs_malloc_counter), ptr, line, file);
	KFREE(ptr);
}
#endif /* FIST_MALLOC_DEBUG */






/* for attach mode, we use a different ->read_super() in attach.c */
super_block_t *
kdb3fs_read_super(super_block_t *sb, void *raw_data, int silent)
{
	super_block_t *ret_sb = NULL;
	int ret = 0;
	DB *dbp1, *dbp2, *dbp3;
	char *database_path = NULL;
	char *direntdb_path = NULL;
	char *datadb_path = NULL;
	char *metadatadb_path = NULL;
	DBT data, key;
	ino_t root_ino;
	int DB_FILE_LEN = 20;
	DBTYPE db_type;

	print_entry_location();


#ifdef FIST_MALLOC_DEBUG
	atomic_set(&kdb3fs_malloc_counter, 0); /* for malloc debugging */
#endif /* FIST_MALLOC_DEBUG */
	
	if (!raw_data) {
		printk(KERN_WARNING "kdb3fs_read_super: missing data argument\n");
		goto out;
	}
	
	/*
	 * Allocate superblock private data
	 */
	stopd(sb) = KMALLOC(sizeof(struct kdb3fs_sb_info), GFP_KERNEL);
	if (!stopd(sb)) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		goto out;
	}

	stopd(sb)->ksi_writepage_sync = SYNC_DATA;
	stopd(sb)->ksi_writeinode_sync = SYNC_MD;

	kdb3fs_parse_options(sb, raw_data, &database_path);

//	printk("database_path: %s\n", database_path);
	
	direntdb_path = KMALLOC(strlen(database_path) + DB_FILE_LEN, GFP_KERNEL);
	if (!direntdb_path) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		goto free_super;
	}
	metadatadb_path = KMALLOC(strlen(database_path) + DB_FILE_LEN, GFP_KERNEL);
	if (!metadatadb_path) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		goto free_super;
	}
	datadb_path = KMALLOC(strlen(database_path) + DB_FILE_LEN, GFP_KERNEL);
	if (!datadb_path) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		goto free_super;
	}

	strcpy(direntdb_path, database_path);
	strcpy(metadatadb_path, database_path);
	strcpy(datadb_path, database_path);
	/* creating database files  dir/dirent.db, dir/data.db and metadata.db */
	if (database_path[strlen(database_path) - 1] != '/') {
		strcat(direntdb_path, "/");
		strcat(metadatadb_path, "/");
		strcat(datadb_path, "/");
	}
	strcat(direntdb_path, "dirent.db");
	strcat(datadb_path, "data.db");
	strcat(metadatadb_path, "metadata.db");

	/* opening the three databases */
	/* opening dirent.db */
	if ((ret = db_create(&dbp1, NULL, 0)) != 0) { 
		printk("db_create: %d\n", ret); 
		goto free_super;
	}

	/* XXX: This should *not* Oops when the database doesn't exist. */
	if ((ret = dbp1->open(dbp1, NULL, direntdb_path, NULL, DB_UNKNOWN, 0, 0)) != 0) { 
		dbp1->err(dbp1, ret, "%s", direntdb_path); 
		printk("error in opening %s: %d\n", direntdb_path, ret); 
		goto close_dbp1; 
	}

	/* opening metadata.db */
	if ((ret = db_create(&dbp2, NULL, 0)) != 0) { 
		printk("db_create: %d\n", ret); 
		goto close_dbp1;
	}

	if ((ret = dbp2->open(dbp2, NULL, metadatadb_path, NULL, DB_UNKNOWN, 0, 0)) != 0) { 
		dbp2->err(dbp2, ret, "%s", metadatadb_path); 
		printk("error in opening %s: %d\n", metadatadb_path, ret); 
		goto close_dbp2; 
	}

	/* opening data.db */
	if ((ret = db_create(&dbp3, NULL, 0)) != 0) {
		printk("error in opening %s: %d\n", metadatadb_path, ret); 
		goto close_dbp2;
	}

	if ((ret = dbp3->open(dbp3, NULL, datadb_path, NULL, DB_UNKNOWN, 0, 0)) != 0) { 
		dbp3->err(dbp3, ret, "%s", datadb_path);
		printk("error in opening %s: %d\n", datadb_path, ret); 
		goto close_dbp3; 
	}

	dirent_dbp = dbp1;
	metadata_dbp = dbp2;
	data_dbp = dbp3;
	
//	displayDB("dirent.db", dbp1);
//	displayDB("metadata.db", dbp2);
//	displayDB("data.db", dbp3);

	/*
	 * Linux 2.4.2-ac3 and beyond has code in
	 * mm/filemap.c:generic_file_write() that requires sb->s_maxbytes
	 * to be populated.  If not set, all write()s under that sb will
	 * return 0.
	 *
	 * Linux 2.4.4+ automatically sets s_maxbytes to MAX_NON_LFS;
	 * the filesystem should override it only if it supports LFS.
	 */
	/* non-SCA code is good to go with LFS */
	sb->s_maxbytes = KDB3FS_MAX_FILE_LENGTH;
	
	sb->s_op = &kdb3fs_sops;
	/*
	 * we can't use d_alloc_root if we want to use
	 * our own interpose function unchanged,
	 * so we simply replicate *most* of the code in d_alloc_root here
	 */
	sb->s_root = d_alloc(NULL, &(const struct qstr) { "/", 1, 0 });
	if (IS_ERR(sb->s_root)) {
		printk(KERN_WARNING "kdb3fs_read_super: d_alloc failed\n");
		goto close_dbp3;
	}

	sb->s_root->d_op = &kdb3fs_dops;
	sb->s_root->d_sb = sb;
	sb->s_root->d_parent = sb->s_root;


	/* verifying that the "." and ".." entries exist in the dirent.db database */
	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	key.data = ".";  
	key.size = sizeof(".");
	if ((ret = dirent_dbp->get(dirent_dbp, NULL, &key, &data, 0)) == 0) {
//		printk("db: %s: key retrieved: data was %s, size=%d\n", (char *)key.data, (char *)data.data, data.size); 
	} else {
		if (ret == DB_NOTFOUND) {
			printk("Could'nt find %s in dirent database.\n", (char *)key.data); 
		} else {
			printk("Get operation for %s unsuccessful.\n", (char *)key.data); 
		}
		goto out_dput;
	}


	memset(&key, 0, sizeof(key)); 
	memset(&data, 0, sizeof(data)); 
	key.data = "..";  
	key.size = sizeof("..");
	if ((ret = dirent_dbp->get(dirent_dbp, NULL, &key, &data, 0)) == 0) {
//		printk("db: %s: key retrieved: data was %s, size=%d\n", (char *)key.data, (char *)data.data, data.size); 
	} else {
		if (ret == DB_NOTFOUND) {
			printk("Could'nt find %s in dirent database.\n", (char *)key.data); 
		} else {
			printk("Get operation for %s unsuccessful.\n", (char *)key.data); 
		}
		goto out_dput;
	}

	/* verified that both . and .. exist at this point*/

	root_ino = *((u_int32_t *) data.data);

//	printk("calling interpose root-ino=%d\n", (int)root_ino);
	if (kdb3fs_interpose(sb->s_root, sb, 1, root_ino, 0))
		printk("ERROR in read_super(), interpose()!!\n");

	ret_sb = sb;
	goto out;
	
out_dput:
	dput(sb->s_root);

close_dbp3:
	dbp3->close(dbp3, 0);

close_dbp2:
	dbp2->close(dbp2, 0);

close_dbp1:
	dbp1->close(dbp1, 0);

free_super:
	KFREE(stopd(sb));
	stopd(sb) = NULL;

out:
	if(sb) {
		fist_print_sb("OUT sb", sb);
	}

	KFREE(database_path);
	database_path = NULL;
	KFREE(datadb_path);
	datadb_path = NULL;
	KFREE(metadatadb_path);
	metadatadb_path = NULL;
	KFREE(direntdb_path);
	direntdb_path = NULL;
	
	print_exit_location();
	return ret_sb;
}




/*----*/
// this structure *must* be static!!! (or the memory for 'name' gets
// corrupted in 2.3...)
static DECLARE_FSTYPE(kdb3fs_fs_type, "kdb3fs", kdb3fs_read_super, 0);

static int __init init_kdb3fs_fs(void)
{
	printk("Registering kdb3fs version $Id: main.c,v 1.25 2003/12/22 10:51:22 zubair Exp $\n");
	return register_filesystem(&kdb3fs_fs_type);
}
static void __exit exit_kdb3fs_fs(void)
{
	printk("Unregistering kdb3fs version $Id: main.c,v 1.25 2003/12/22 10:51:22 zubair Exp $\n");
	unregister_filesystem(&kdb3fs_fs_type);
}

EXPORT_NO_SYMBOLS;
MODULE_AUTHOR("Erez Zadok <ezk@cs.sunysb.edu>");
MODULE_DESCRIPTION("FiST-generated kdb3fs filesystem");
MODULE_LICENSE("GPL");

MODULE_PARM(fist_debug_var, "i");
MODULE_PARM_DESC(fist_debug_var, "Debug level");

module_init(init_kdb3fs_fs)
module_exit(exit_kdb3fs_fs)

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */
